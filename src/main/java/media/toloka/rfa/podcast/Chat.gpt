package com.example.podcast;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import javax.persistence.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@SpringBootApplication
@EnableScheduling
public class PodcastApplication {

    public static void main(String[] args) {
        SpringApplication.run(PodcastApplication.class, args);
    }
}

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
class Podcast {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;
    private String description;
    private String link;
    private String language;
    private String imageUrl;
    private String copyright;
    private String lastBuildDate;
    private String author;
}

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
class Episode {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;
    private String description;
    private String audioUrl;
    private LocalDateTime publishDate;

    @ManyToOne
    private Podcast podcast;
}

interface PodcastRepository extends JpaRepository<Podcast, Long> {
    Optional<Podcast> findByLink(String link);
}

interface EpisodeRepository extends JpaRepository<Episode, Long> {
    List<Episode> findByPodcast(Podcast podcast);
    Optional<Episode> findByPodcastAndAudioUrl(Podcast podcast, String audioUrl);
}

@Service
class PodcastService {

    @Autowired
    private PodcastRepository podcastRepository;

    @Autowired
    private EpisodeRepository episodeRepository;

    private static final String RSS_FEED_URL = "your_rss_feed_url_here"; // Вставити ваш URL

    public void downloadAndSavePodcast() {
        try {
            // Зчитуємо RSS-фід
            RestTemplate restTemplate = new RestTemplate();
            String rssFeed = restTemplate.getForObject(RSS_FEED_URL, String.class);

            // Парсимо RSS (XML) за допомогою DOM
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            InputStream inputStream = new URL(RSS_FEED_URL).openStream();
            org.w3c.dom.Document document = builder.parse(inputStream);
            document.getDocumentElement().normalize();

            // Отримуємо елементи <channel>
            org.w3c.dom.Node channelNode = document.getElementsByTagName("channel").item(0);
            org.w3c.dom.Element channelElement = (org.w3c.dom.Element) channelNode;

            // Зчитуємо всі атрибути подкасту
            String podcastTitle = channelElement.getElementsByTagName("title").item(0).getTextContent();
            String podcastDescription = channelElement.getElementsByTagName("description").item(0).getTextContent();
            String podcastLink = channelElement.getElementsByTagName("link").item(0).getTextContent();
            String podcastLanguage = channelElement.getElementsByTagName("language").item(0).getTextContent();
            String podcastImageUrl = channelElement.getElementsByTagName("image").item(0) != null ?
                    channelElement.getElementsByTagName("image").item(0).getTextContent() : "";
            String podcastCopyright = channelElement.getElementsByTagName("copyright").item(0) != null ?
                    channelElement.getElementsByTagName("copyright").item(0).getTextContent() : "";
            String podcastLastBuildDate = channelElement.getElementsByTagName("lastBuildDate").item(0).getTextContent();
            String podcastAuthor = channelElement.getElementsByTagName("author").item(0) != null ?
                    channelElement.getElementsByTagName("author").item(0).getTextContent() : "";

            // Перевіряємо, чи вже є подкаст в базі
            Podcast podcast = podcastRepository.findByLink(podcastLink)
                    .orElse(new Podcast(podcastTitle, podcastDescription, podcastLink, podcastLanguage,
                            podcastImageUrl, podcastCopyright, podcastLastBuildDate, podcastAuthor));

            // Зберігаємо або оновлюємо подкаст
            podcastRepository.save(podcast);

            // Обробляємо кожен епізод
            org.w3c.dom.NodeList items = channelElement.getElementsByTagName("item");
            for (int i = 0; i < items.getLength(); i++) {
                org.w3c.dom.Node itemNode = items.item(i);
                org.w3c.dom.Element itemElement = (org.w3c.dom.Element) itemNode;

                String episodeTitle = itemElement.getElementsByTagName("title").item(0).getTextContent();
                String episodeDescription = itemElement.getElementsByTagName("description").item(0).getTextContent();
                String episodeAudioUrl = itemElement.getElementsByTagName("enclosure").item(0).getAttributes()
                        .getNamedItem("url").getTextContent();
                String episodePublishDateString = itemElement.getElementsByTagName("pubDate").item(0).getTextContent();
                LocalDateTime episodePublishDate = LocalDateTime.parse(episodePublishDateString);

                // Перевірка, чи є такий епізод у базі
                if (episodeRepository.findByPodcastAndAudioUrl(podcast, episodeAudioUrl).isEmpty()) {
                    // Завантажуємо аудіофайл
                    downloadAudioFile(episodeAudioUrl, episodeTitle);

                    // Створюємо новий епізод
                    Episode episode = new Episode(episodeTitle, episodeDescription, episodeAudioUrl, episodePublishDate);
                    episode.setPodcast(podcast);

                    // Зберігаємо новий епізод
                    episodeRepository.save(episode);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void downloadAudioFile(String audioUrl, String episodeTitle) {
        try {
            URL url = new URL(audioUrl);
            try (InputStream in = url.openStream()) {
                // Тут потрібно реалізувати збереження аудіофайлу на диск або в базу даних
                String fileName = episodeTitle.replaceAll("[^a-zA-Z0-9]", "_") + ".mp3";
                Files.copy(in, Paths.get("audio/" + fileName), StandardCopyOption.REPLACE_EXISTING);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void checkForNewEpisodes() {
        List<Podcast> podcasts = podcastRepository.findAll();
        for (Podcast podcast : podcasts) {
            // Завантажуємо і перевіряємо нові епізоди для кожного подкасту
            downloadAndSavePodcast();
        }
    }
}

@Component
class PodcastScheduler {

    @Autowired
    private PodcastService podcastService;

    @Scheduled(fixedRate = 3600000)  // Перевіряти кожну годину
    public void fetchAndSavePodcast() {
        podcastService.checkForNewEpisodes();
    }
}

@Component
class CommandLineAppStartupRunner implements CommandLineRunner {

    @Autowired
    private PodcastService podcastService;

    @Override
    public void run(String... args) throws Exception {
        // Викликаємо завантаження подкастів одразу при запуску додатка
        podcastService.checkForNewEpisodes();
    }
}
