Ось детально прокоментований код програми, яка зчитує RSS з URL, завантажує аудіофайли епізодів та зберігає подкасти з усіма атрибутами в базі даних. Програма також перевіряє нові епізоди для всіх подкастів в базі.

```java
package com.example.podcast;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import javax.persistence.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

// Основний клас Spring Boot додатка
@SpringBootApplication
@EnableScheduling  // Дозволяє планування завдань
public class PodcastApplication {

    public static void main(String[] args) {
        SpringApplication.run(PodcastApplication.class, args); // Запуск Spring Boot додатка
    }
}

// Модель для зберігання інформації про подкаст у базі даних
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
class Podcast {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;  // Унікальний ідентифікатор подкасту

    private String title;  // Назва подкасту
    private String description;  // Опис подкасту
    private String link;  // URL подкасту
    private String language;  // Мова подкасту
    private String imageUrl;  // URL зображення подкасту
    private String copyright;  // Авторські права
    private String lastBuildDate;  // Остання дата побудови подкасту
    private String author;  // Автор подкасту

    // Атрибути iTunes
    private String itunesAuthor;  // Автор для iTunes
    private String itunesCategory;  // Категорія iTunes
    private String itunesExplicit;  // Позначка для явного контенту
    private String itunesImageUrl;  // URL зображення для iTunes

    // Атрибути Atom
    private String atomLink;  // Atom link для подкасту
    private String generator;  // Генератор RSS
}

// Модель для зберігання епізодів подкасту
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
class Episode {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;  // Унікальний ідентифікатор епізоду

    private String title;  // Назва епізоду
    private String description;  // Опис епізоду
    private String audioUrl;  // URL аудіофайлу епізоду
    private LocalDateTime publishDate;  // Дата публікації епізоду

    @ManyToOne
    private Podcast podcast;  // Подкаст, до якого належить цей епізод
}

// Репозиторій для роботи з подкастами
interface PodcastRepository extends JpaRepository<Podcast, Long> {
    Optional<Podcast> findByLink(String link);  // Знайти подкаст за його URL
}

// Репозиторій для роботи з епізодами
interface EpisodeRepository extends JpaRepository<Episode, Long> {
    List<Episode> findByPodcast(Podcast podcast);  // Знайти всі епізоди певного подкасту
    Optional<Episode> findByPodcastAndAudioUrl(Podcast podcast, String audioUrl);  // Знайти епізод за URL аудіофайлу
}

// Сервіс для завантаження та збереження подкастів та епізодів
@Service
class PodcastService {

    @Autowired
    private PodcastRepository podcastRepository;

    @Autowired
    private EpisodeRepository episodeRepository;

    private static final String RSS_FEED_URL = "your_rss_feed_url_here";  // URL для зчитування RSS (замінити на ваш)

    // Завантаження і збереження подкасту та епізодів
    public void downloadAndSavePodcast() {
        try {
            // Використовуємо RestTemplate для отримання RSS-фіду
            RestTemplate restTemplate = new RestTemplate();
            String rssFeed = restTemplate.getForObject(RSS_FEED_URL, String.class);

            // Ініціалізуємо фабрику для парсингу XML
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            DocumentBuilder builder = factory.newDocumentBuilder();
            InputStream inputStream = new URL(RSS_FEED_URL).openStream();
            org.w3c.dom.Document document = builder.parse(inputStream);
            document.getDocumentElement().normalize();  // Нормалізуємо XML (видаляємо зайві пробіли)

            // Отримуємо елементи <channel> для парсингу
            org.w3c.dom.Node channelNode = document.getElementsByTagName("channel").item(0);
            org.w3c.dom.Element channelElement = (org.w3c.dom.Element) channelNode;

            // Зчитуємо основні атрибути подкасту
            String podcastTitle = channelElement.getElementsByTagName("title").item(0).getTextContent();
            String podcastDescription = channelElement.getElementsByTagName("description").item(0).getTextContent();
            String podcastLink = channelElement.getElementsByTagName("link").item(0).getTextContent();
            String podcastLanguage = channelElement.getElementsByTagName("language").item(0).getTextContent();
            String podcastImageUrl = channelElement.getElementsByTagName("image").item(0) != null ?
                    channelElement.getElementsByTagName("image").item(0).getTextContent() : "";
            String podcastCopyright = channelElement.getElementsByTagName("copyright").item(0) != null ?
                    channelElement.getElementsByTagName("copyright").item(0).getTextContent() : "";
            String podcastLastBuildDate = channelElement.getElementsByTagName("lastBuildDate").item(0).getTextContent();
            String podcastAuthor = channelElement.getElementsByTagName("author").item(0) != null ?
                    channelElement.getElementsByTagName("author").item(0).getTextContent() : "";

            // Зчитуємо атрибути для iTunes
            String itunesAuthor = getElementValue(channelElement, "itunes:author");
            String itunesCategory = getElementValue(channelElement, "itunes:category");
            String itunesExplicit = getElementValue(channelElement, "itunes:explicit");
            String itunesImageUrl = getElementValue(channelElement, "itunes:image");

            // Зчитуємо атрибути для Atom
            String atomLink = getElementValue(channelElement, "atom:link");
            String generator = getElementValue(channelElement, "generator");

            // Перевірка наявності подкасту в базі
            Podcast podcast = podcastRepository.findByLink(podcastLink)
                    .orElse(new Podcast(podcastTitle, podcastDescription, podcastLink, podcastLanguage,
                            podcastImageUrl, podcastCopyright, podcastLastBuildDate, podcastAuthor,
                            itunesAuthor, itunesCategory, itunesExplicit, itunesImageUrl, atomLink, generator));

            // Зберігаємо або оновлюємо подкаст у базі даних
            podcastRepository.save(podcast);

            // Обробка всіх епізодів
            org.w3c.dom.NodeList items = channelElement.getElementsByTagName("item");
            for (int i = 0; i < items.getLength(); i++) {
                org.w3c.dom.Node itemNode = items.item(i);
                org.w3c.dom.Element itemElement = (org.w3c.dom.Element) itemNode;

                // Зчитуємо атрибути епізоду
                String episodeTitle = itemElement.getElementsByTagName("title").item(0).getTextContent();
                String episodeDescription = itemElement.getElementsByTagName("description").item(0).getTextContent();
                String episodeAudioUrl = itemElement.getElementsByTagName("enclosure").item(0).getAttributes()
                        .getNamedItem("url").getTextContent();
                String episodePublishDateString = itemElement.getElementsByTagName("pubDate").item(0).getTextContent();
                LocalDateTime episodePublishDate = LocalDateTime.parse(episodePublishDateString);

                // Перевірка, чи епізод вже існує в базі
                if (episodeRepository.findByPodcastAndAudioUrl(podcast, episodeAudioUrl).isEmpty()) {
                    // Завантажуємо аудіофайл
                    downloadAudioFile(episodeAudioUrl, episodeTitle);

                    // Створюємо та зберігаємо новий епізод
                    Episode episode = new Episode(episodeTitle, episodeDescription, episodeAudioUrl, episodePublishDate);
                    episode.setPodcast(podcast);
                    episodeRepository.save(episode);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    // Метод для отримання значення елемента, якщо він існує
    private String getElementValue(org.w3c.dom.Element parentElement, String tagName) {
        org.w3c.dom.NodeList nodes = parentElement.getElementsByTagName(tagName);
        return nodes.getLength() > 0 ? nodes.item(0).getTextContent() : "";
    }

    // Метод для завантаження аудіофайлу епізоду
    private void downloadAudioFile(String audioUrl, String episodeTitle) {
        try {
            URL url = new URL(audioUrl);
            try (InputStream in = url.openStream()) {
                // Завантажуємо файл на диск
                String fileName = episodeTitle.replaceAll("[^a-zA-Z0-9]", "_") + ".mp3";
                Files.copy(in, Paths.get("audio/" + fileName), StandardCopyOption.REPLACE_EXISTING);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Перевірка нових епізодів для всіх подкастів в базі
    public void checkForNewEpisodes() {
        List<Podcast> podcasts = podcastRepository.findAll();
        for (Podcast podcast : podcasts) {
            // Завантажуємо та перевіряємо нові епізоди для кожного подкасту
            downloadAndSavePodcast();
        }
    }
}

// Планувальник для виконання завдань з регулярними інтервалами
@Component
class PodcastScheduler {

    @Autowired
    private PodcastService podcastService;

    @Scheduled(fixedRate = 3600000)  // Виконувати кожну годину
    public void fetchAndSavePodcast() {
        podcastService.checkForNewEpisodes();
    }
}

// Клас для запуску завдання при старті додатка
@Component
class CommandLineAppStartupRunner implements CommandLineRunner {

    @Autowired
    private PodcastService podcastService;

    @Override
    public void run(String... args) throws Exception {
        // Завантаження подкастів та епізодів при запуску програми
        podcastService.checkForNewEpisodes();
    }
}
```

### Пояснення коду:

1. **Основний клас `PodcastApplication`**:
   - Запускає Spring Boot додаток.
   - Використовує анотацію `@EnableScheduling` для запуску запланованих завдань.

2. **Моделі `Podcast` та `Episode`**:
   - `Podcast`: Містить всю необхідну інформацію про подкаст, включаючи атрибути iTunes та Atom.
   - `Episode`: Містить інформацію про кожен епізод подкасту.

3. **Репозиторії `PodcastRepository` та `EpisodeRepository`**:
   - Вони використовуються для взаємодії з базою даних: знаходження та збереження подкастів та епізодів.

4. **Сервіс `PodcastService`**:
   - Зчитує RSS фід за допомогою `RestTemplate` і парсить його через DOM.
   - Завантажує та зберігає подкасти та епізоди, перевіряє, чи є нові епізоди в базі.

5. **Методи `getElementValue` і `downloadAudioFile`**:
   - `getElementValue` дозволяє отримати значення з елементів XML, якщо вони присутні.
   - `downloadAudioFile` завантажує аудіофайл епізоду з URL на диск.

6. **Планувальник `PodcastScheduler`**:
   - Використовує анотацію `@Scheduled` для виконання перевірки нових епізодів кожну годину.

7. **Командний рядок `CommandLineAppStartupRunner`**:
   - Запускає перевірку нових епізодів одразу при старті програми.

### Запуск програми:
1. Вставте ваш RSS URL у змінну `RSS_FEED_URL`.
2. Переконайтесь, що база даних налаштована (наприклад, H2 або MySQL).
3. Запустіть Spring Boot додаток.

Це дозволить автоматично зчитувати, завантажувати та зберігати подкасти з усіма атрибутами, а також перевіряти нові епізоди.



<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Podcast Details</title>
</head>
<body>
    <h1 th:text="${podcast.title}"></h1>
    <img th:src="${podcast.imageUrl}" alt="Podcast Image">
    <p th:text="${podcast.description}"></p>
    <a th:href="${podcast.link}" target="_blank">Visit Podcast Website</a>

    <h2>Episodes</h2>
    <ul>
        <li th:each="episode : ${podcast.episodes}">
            <h3 th:text="${episode.title}"></h3>
            <p th:text="${episode.description}"></p>
            <audio th:src="${episode.audioUrl}" controls></audio>
        </li>
    </ul>

    <a href="/">Back to All Podcasts</a>
</body>
</html>



Ось оновлений приклад програми, який включає функцію завантаження подкасту з RSS-посилання, збереження всіх атрибутів подкасту та його епізодів у базу даних, а також відображення всіх полів і атрибутів на одній HTML-сторінці за допомогою Thymeleaf.

---

### Структура проекту:
```
src/main/
├── java/com/example/podcast/
│   ├── PodcastApplication.java
│   ├── model/
│   │   ├── Podcast.java
│   │   ├── Episode.java
│   ├── repository/
│   │   ├── PodcastRepository.java
│   │   ├── EpisodeRepository.java
│   ├── controller/
│   │   ├── PodcastController.java
│   ├── service/
│   │   ├── PodcastService.java
├── resources/
│   ├── templates/
│   │   ├── podcast.html
│   ├── application.properties
```

---

### Код програми

#### `PodcastApplication.java`
```java
package com.example.podcast;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PodcastApplication {
    public static void main(String[] args) {
        SpringApplication.run(PodcastApplication.class, args);
    }
}
```

---

#### Моделі

##### `Podcast.java`
```java
package com.example.podcast.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
public class Podcast {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String description;
    private String link;
    private String imageUrl;
    private String author;

    @OneToMany(mappedBy = "podcast", cascade = CascadeType.ALL)
    private List<Episode> episodes;
}
```

##### `Episode.java`
```java
package com.example.podcast.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import javax.persistence.*;
import java.time.LocalDateTime;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
public class Episode {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;
    private String description;
    private String audioUrl;
    private LocalDateTime publishDate;

    @ManyToOne
    private Podcast podcast;
}
```

---

#### Репозиторії

##### `PodcastRepository.java`
```java
package com.example.podcast.repository;

import com.example.podcast.model.Podcast;
import org.springframework.data.jpa.repository.JpaRepository;

public interface PodcastRepository extends JpaRepository<Podcast, Long> {
}
```

##### `EpisodeRepository.java`
```java
package com.example.podcast.repository;

import com.example.podcast.model.Episode;
import org.springframework.data.jpa.repository.JpaRepository;

public interface EpisodeRepository extends JpaRepository<Episode, Long> {
}
```

---

#### Сервіс для роботи з RSS

##### `PodcastService.java`
```java
package com.example.podcast.service;

import com.example.podcast.model.Episode;
import com.example.podcast.model.Podcast;
import com.example.podcast.repository.PodcastRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Service
public class PodcastService {

    @Autowired
    private PodcastRepository podcastRepository;

    public Podcast fetchPodcastFromRSS(String rssUrl) throws Exception {
        // Парсинг RSS
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(rssUrl);

        Element channel = (Element) document.getElementsByTagName("channel").item(0);

        // Створення подкасту
        Podcast podcast = new Podcast();
        podcast.setTitle(getElementValue(channel, "title"));
        podcast.setDescription(getElementValue(channel, "description"));
        podcast.setLink(getElementValue(channel, "link"));
        podcast.setImageUrl(getImageUrl(channel));
        podcast.setAuthor(getElementValue(channel, "itunes:author"));

        // Додавання епізодів
        NodeList items = document.getElementsByTagName("item");
        List<Episode> episodes = new ArrayList<>();
        for (int i = 0; i < items.getLength(); i++) {
            Node node = items.item(i);
            if (node.getNodeType() == Node.ELEMENT_NODE) {
                Element item = (Element) node;
                Episode episode = new Episode();
                episode.setTitle(getElementValue(item, "title"));
                episode.setDescription(getElementValue(item, "description"));
                episode.setAudioUrl(getElementValue(item, "enclosure"));
                String pubDate = getElementValue(item, "pubDate");
                episode.setPublishDate(parseDate(pubDate));
                episode.setPodcast(podcast);
                episodes.add(episode);
            }
        }
        podcast.setEpisodes(episodes);

        return podcastRepository.save(podcast);
    }

    private String getElementValue(Element parent, String tagName) {
        Node node = parent.getElementsByTagName(tagName).item(0);
        return node != null ? node.getTextContent() : null;
    }

    private String getImageUrl(Element channel) {
        Node imageNode = channel.getElementsByTagName("itunes:image").item(0);
        if (imageNode != null && imageNode.getNodeType() == Node.ELEMENT_NODE) {
            Element imageElement = (Element) imageNode;
            return imageElement.getAttribute("href");
        }
        return null;
    }

    private LocalDateTime parseDate(String date) {
        DateTimeFormatter formatter = DateTimeFormatter.RFC_1123_DATE_TIME;
        return LocalDateTime.parse(date, formatter);
    }
}
```

---

#### Контролер

##### `PodcastController.java`
```java
package com.example.podcast.controller;

import com.example.podcast.model.Podcast;
import com.example.podcast.service.PodcastService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class PodcastController {

    @Autowired
    private PodcastService podcastService;

    @GetMapping("/")
    public String showForm() {
        return "podcast";
    }

    @PostMapping("/fetch")
    public String fetchPodcast(@RequestParam String rssUrl, Model model) {
        try {
            Podcast podcast = podcastService.fetchPodcastFromRSS(rssUrl);
            model.addAttribute("podcast", podcast);
        } catch (Exception e) {
            model.addAttribute("error", "Failed to fetch podcast: " + e.getMessage());
        }
        return "podcast";
    }
}
```

---

#### Шаблон Thymeleaf

##### `podcast.html`
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Podcast Viewer</title>
</head>
<body>
    <h1>Fetch Podcast</h1>
    <form method="post" action="/fetch">
        <label for="rssUrl">RSS URL:</label>
        <input type="text" id="rssUrl" name="rssUrl" required>
        <button type="submit">Fetch</button>
    </form>

    <div th:if="${podcast}">
        <h1 th:text="${podcast.title}"></h1>
        <p th:text="${podcast.description}"></p>
        <img th:src="${podcast.imageUrl}" alt="Podcast Image">
        <p><b>Author:</b> <span th:text="${podcast.author}"></span></p>
        <p><b>Link:</b> <a th:href="${podcast.link}" th:text="${podcast.link}" target="_blank"></a></p>

        <h2>Episodes</h2>
        <ul>
            <li th:each="episode : ${podcast.episodes}">
                <h3 th:text="${episode.title}"></h3>
                <p th:text="${episode.description}"></p>
                <audio th:src="${episode.audioUrl}" controls></audio>
                <p th:text="'Published: ' + ${episode.publishDate}"></p>
            </li>
        </ul>
    </div>

    <div th:if="${error}">
        <p th:text="${error}" style="color: red;"></p>
    </div>
</body>
</html>
```

---

### `application.properties`
```properties
spring.datasource.url=jdbc:h2:mem:podcastdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password
spring.jpa.hibernate.ddl-auto=create
spring.h2.console.enabled=true
spring.thymeleaf.cache=false
```

---

### Як запустити:

1. Запустіть програму за допомогою `mvn spring-boot:run`.
2. Відкрийте [http://localhost:8080](http://localhost:8080) у браузері.
3. Введіть URL RSS-каналу подкасту та натисніть "Fetch".
4. Перегляньте інформацію про подкаст і список його епізодів.